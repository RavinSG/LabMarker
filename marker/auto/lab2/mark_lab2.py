import os

from config import bcolors
from marker.auto.ProcessHandler import ProcessHandler
from marker.utils import print_and_get_sub_selection


def find_file(search_folder, file_name):
    """
    Recursively checks through folders to identify the location of the file with the name "file_name". Will only search
    for files with the extensions .py, .java, and .c. If no file with a matching file name is found, the function will
    return None, else the path to the file will be returned.

    :param search_folder: Path of the top directory to be searched in
    :param file_name: Name of the file to be searched, without the extension
    :return: Path of the file if found
    """

    current_files = os.listdir(search_folder)
    lang_map = {
        ".py": "Python",
        ".java": "Java",
        ".c": "C"
    }
    directories = []

    for directory in current_files:
        current_file_name, current_file_ext = os.path.splitext(directory)
        if current_file_name == file_name:
            if current_file_ext in [".py", ".c", ".java"]:
                return {"folder_path": search_folder, "ext": current_file_ext, "language": lang_map[current_file_ext]}
        else:
            temp_path = os.path.join(search_folder, directory)
            if os.path.isdir(temp_path):
                directories.append(temp_path)

    for directory in directories:
        return find_file(directory, file_name)

    return None


def run_lab_2_code(code_file_dir, code_lang, out_stream, port_num=12000):
    """
    Runs a code file from its directory and writes all the outputs generated by the code to an output stream.

    :param code_file_dir: The directory the code file is located
    :param code_lang: The language the code is written in
    :param out_stream: Where the output should be written to. If none provided, the output will be printed to console
    :param port_num: The port PingServer is running on
    :return: Exit code of the program
    """

    process_commands = {
        "Python": f"python PingClient.py localhost {port_num}",
        "C": f"./PingClient localhost {port_num}",
        "Java": f"java PingClient localhost {port_num}"
    }

    if code_lang == "Python":
        client = ProcessHandler(process_commands["Python"], out_stream=out_stream, cwd=code_file_dir)

    elif code_lang == "Java":
        os.system(f"javac {os.path.join(code_file_dir, 'PingClient.java')}")
        client = ProcessHandler(process_commands["Java"], out_stream=out_stream, cwd=code_file_dir)

    else:
        print(f"{bcolors.WARNING}There is no current implementation for C files, skipping evaluation{bcolors.ENDC}")
        out_stream.write("Code implemented in C, Please check manually!")
        return 0

    # If the client exists before 0.1 seconds, it has probably encountered an error
    client.get_output(timeout=0.1)
    if not client.is_alive:
        return -1

    try:
        count = 0
        while True:
            client.get_output(timeout=0.1)
            count += 1

            # Do not wait indefinitely for the client output, after a maximum of 30 seconds, the process will be
            # terminated by force.
            if count > 300:
                client.kill_process()
                return -1  # TODO: Change exit code to distinguish between immediate exit vs forced termination

    except ChildProcessError:
        # TODO: Add a time check to verify whether the program executed properly
        return 0


def run_individual_submission(submission_path, out_stream):
    """
    Checks if a file with the name 'PingClient' exists in the given directory or any of the subdirectories. If not
    present, will return an exit code of -2. Else, based on the execution of the code, the relevant exit code will be
    returned.

    :param submission_path: Directory to search for the code file
    :param out_stream: Where the output should be written to
    :return: Exit code of the program
    """

    code_file = find_file(submission_path, "PingClient")

    if code_file is None:
        if out_stream is None:
            print("File not found")
        else:
            out_stream.write("File not found")
        return -2

    return run_lab_2_code(code_file["folder_path"], code_file["language"], out_stream)


def get_error_message(status_no):
    """
    Based on the exit status of the program, returns the relevant error message if an error has occurred.
    """

    error_message = None

    if status_no == -1:
        error_message = "Process terminated unexpectedly"
    elif status_no == -2:
        error_message = "File not found"

    return error_message


def mark_submissions_manually(class_path, output_destination):
    """
    User can select which submission they want to mark and mark them individually.

    :param class_path: Path of the folder containing all submissions for a single class
    :param output_destination: Directory where the outputs for each program should be written to
    :return: None
    """

    if not os.path.exists(output_destination):
        os.mkdir(output_destination)

    print(f"{bcolors.OKGREEN}Evaluating labs manually, Please select lab to continue{bcolors.ENDC}\n")
    class_submissions = os.listdir(class_path)

    while True:
        lab_num = print_and_get_sub_selection(class_submissions)
        submission_path = os.path.join(class_path, class_submissions[lab_num])
        code_output_file = open(f'{output_destination}/{class_submissions[lab_num]}_output.txt', "w")

        print(f"{bcolors.OKGREEN}Running code for submission {class_submissions[lab_num]}....{bcolors.ENDC}")

        status = run_individual_submission(submission_path, code_output_file)
        if status != 0:
            print(f"{bcolors.FAIL}{get_error_message(status)}{bcolors.ENDC}")
        else:
            print(f"{bcolors.OKGREEN}Done{bcolors.ENDC}\n")

        code_output_file.close()
